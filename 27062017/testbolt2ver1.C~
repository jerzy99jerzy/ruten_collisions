Double_t funPt_Y_teta (Double_t *xval, Double_t *par)
{
	Double_t y=xval[0];
	Double_t m=par[0];
	Double_t teta=par[1];

	double mpi = 0.139;
	double x=sinh(y)*tan(teta);
	Double_t pt;
	
	if (1. - x*x >= 0. ) 
	pt = mpi* x / TMath::Sqrt(1. - x*x);
    else pt = -1; 
	//cout << teta << endl;
	//cout << y << endl;
	cout << 1 - x*x << endl; 

return pt;
}

int testbolt2ver1()

{
	TCanvas *can1 = new TCanvas("can1", "can1", 550, 440);
	TH1F *h1 = new TH1F ("h1", "histogram", 100, 0, 2);

	TRandom3 r;

 r.SetSeed(); // tworzę r obiekt klasy TRandom3

	double m = 0.938; //masa nukleonu
 	double mpi = 0.139; // masa pionu
	double mn = m;
	double T_beam = 1.65; // ENERGIA kinetyczna wiązki
	double p_beam = 2.41; 	// pęd wiązki wyznaczony z relatywistycznej zależnosci pędu, masy, energii

 TF1 *momentum = new TF1 ("momentum", "[0]*x*x*exp(-sqrt(x*x+[2]*[2])/[1])", 0, 10); // poniewaz zakres 0-10 to temp w GeV.
 TF1 *fteta = new TF1 ("fteta", "sin(x)", 0, TMath::Pi()); // nowa funkcja - teta, generujaca sinus x dla pzedzialu 0 do pi

 TF1 *fteta20 = new TF1 ("fteta20", funPt_Y_teta, 0, 3 ,2);
 TF1 *fteta85 = new TF1 ("fteta85", funPt_Y_teta, 0, 0.2, 2);
 fteta20->SetNpx(1000); 
 fteta85->SetNpx(1000);

	fteta20->SetParameter(0,mpi);
	fteta20->SetParameter(1,20.*(M_PI/180));
	fteta85->SetParameter(0,mpi);
	fteta85->SetParameter(1, 85.*(M_PI/180));

	momentum->SetParameter (0, 1); // przepisujemy rozklad boltzmana dla generacji rozkladu pionow nie protonw
 	momentum->SetParameter (1, 0.07);
	momentum->FixParameter (2, mpi); // poniewaz masa wychodzi ujemna przy SetParameter przy Fit

	double betaCM = p_beam/(2*m+T_beam);
	double gammaCM = 1./sqrt(1-pow(betaCM ,2));
	double p;  // dlugosc wektora pedu
	double fi;

	double px;
	double py;
	double pz;
	double pzlab;
	double plab; // pęd w LAB (dodano 22.06.2017)
	double teta;

	double pt; // poprzeczny
	double E; // energia (kinetyczna)
	double y; // pospiesznosc (rapidity)
	double Elab; // energia w LAB
	double ylab; // rapidity w LAB
	double tetalab; // wartość kąta theta w LAB (dodano 22.06.2017)
	double filab;




 TH2F* h = new TH2F("h","h",50, -1,1,50,0,1.5);  //histogram
 TH2F* h_w_lab = new TH2F("h_w_lab","h_w_lab",100, -1,3,50,0,1.5); // docelowo histogram w LAB (zmiana parametrów?)
 TH2F* hpty_ok = new TH2F("hpty_ok", "hpty_ok",100, -1,3,50,0,1.5); // tymczasowo skopiowałem wartości parammetrów od tego powyzej (!)

 for (int i=0 ; i<1000000; i++) // pętla dla miliona cząstek

 {

	p=momentum->GetRandom();  // losujemy ped (Boltzmann)
	fi=r.Rndm()*2.*TMath::Pi(); // generujemy wartosc fi w przedziale 0 do 2pi
	teta=fteta->GetRandom();

	px=p*sin(teta)*cos(fi);
	py=p*sin(teta)*sin(fi);
	pz=p*cos(teta);
			E=sqrt(p*p+mpi*mpi);
 			Elab=gammaCM*(E+betaCM*pz);
			pzlab=gammaCM*(pz+betaCM*E);

			ylab=0.5*log((Elab+pzlab)/(Elab-pzlab));
			// cout<<"betaCM =" <<betaCM<<endl;

				plab=sqrt(px*px+py*py+pzlab*pzlab); // pęd w LAB
				tetalab=(acos(pzlab/plab))*(180./M_PI); // kąt theta w LAB - czy tak się oznacza PI z maths.h?


								if( tetalab < 20 || tetalab > 85 ) continue;

												if(plab >= 1.5) continue;

												pt=sqrt(px*px+py*py);

														if(pt <= 0.1) continue;

	y=(1/2.)*log((E+pz)/(E-pz));

	//	h->Fill(y,pt);

							h_w_lab->Fill(ylab,pt);

// h1->Fill(momentum->GetRandom() );

 }

h->Draw("colz");
h_w_lab->Draw("colz");

fteta20 -> Draw("same");
fteta85 -> Draw("same");

//h1->Fit(momentum);
//gaus->Print();

return 0;
}
